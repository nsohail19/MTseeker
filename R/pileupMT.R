#' Pileup the mitochondrial reads in a BAM, for variant calling or CN purposes. 
#'
#' If a BAM filename is given, but no ScanBamParam, scanMT(bam) will be called. 
#' Human mitochondrial genomes (GRCh37+ and hg38+) are fully supported, mouse
#' mitochondrial genomes (C57BL/6J aka NC_005089) are only somewhat supported.
#' 
#' @param bam       BAM (must be indexed!) file name or object with a @bam slot
#' @param sbp       optional ScanBamParam object (autogenerated if missing) 
#' @param pup       optional PileupParam object (autogenerated if missing)
#' @param ref       aligned reference mitogenome (default is rCRS/GRCh37+)
#' @param ...       additional args to pass on to the pileup() function
#'
#' @return          an MVRanges object, constructed from pileup results 
#' 
#' @import GenomicAlignments
#' @import GenomeInfoDb
#' @import Rsamtools
#' 
#' @examples
#' 
#' library(MTseekerData)
#' BAMdir <- system.file("extdata", "BAMs", package="MTseekerData")
#' 
#' bam <- BAMs[1]
#' 
#' sbp <- scanMT(bam)
#' show(sbp)
#' 
#' pu <- pileupMT(bam, ref="rCRS", sbp=sbp)
#' show(pu) 
#'
#' @export
#'
pileupMT <- function(bam, sbp=NULL, parallel=FALSE, cores=1, pup=NULL, ref=c("rCRS","GRCh37","GRCh38","hg38", "GRCm38","C57BL/6J","NC_005089","mm10"), ...) { 

  # Set the number of cores if running in parallel
  if (parallel) options(mc.cores = cores)
  if (parallel & cores == 1) options(mc.cores = detectCores()/2)
  
  # If you are working with multiple files
  if (length(bam) > 1) {
    
    if(parallel) {
      mvrl <- MVRangesList(mclapply(bam, pileupMT, sbp=sbp, ref=ref, parallel=parallel, cores=cores))
      return(mvrl)
    }
    
    else {
      mvrl <- MVRangesList(lapply(bam, pileupMT, ref=ref, sbp=sbp))
      return(mvrl)
    }
  }
  
  # can support multiple bams if we have sample names
  # perhaps it is worthwhile to autoextract them now
  
  if (is.null(sbp)) sbp <- scanMT(bam) 
  if (is.null(pup)) pup <- PileupParam(distinguish_strands=FALSE) 
  refSeqLengths <- .refSeqLengths() # synonyms 
  ref <- .getRefSyn(match.arg(ref)) # matching 
  
  # scant support for other mitogenomes
  if (!ref %in% names(refSeqLengths)) {
    stop("Only the ", paste(names(refSeqLengths), collapse=" and "),
         " mitochondrial genome", 
         ifelse(length(refSeqLengths) > 1, "s are", " is"),
         " supported by pileupMT() at present.")
  } else { 
    pu <- pileup(file=bam, scanBamParam=sbp, pileupParam=pup, ...)
  }

    # may be handy for editing 
  refSeqDNA <- .getRefSeq(ref)
  
  # will need to handle '-' and '+' separately 
  indels <- subset(pu, nucleotide %in% c('-', '+'))
  if (nrow(indels) > 0) {
    # for obtaining the supporting reads and CIGARs from the BAM: 
    indels$start <- indels$pos
    indels$end <- indels$pos 
    indelSBP <- sbp
    bamWhich(indelSBP) <- as(indels, "GRanges")
    bamWhat(indelSBP) <- "seq"
    indelReads <- readGAlignments(file=bam, param=indelSBP)
    
    # Initialize to get the alternative sequences
    mcols(indelReads)$indelStart <- NA_integer_
    mcols(indelReads)$indelEnd <- NA_integer_
    
    mcols(indelReads)$ref <- NA_character_
    mcols(indelReads)$alt <- NA_character_
    
    # Get the reads the physically contain the insertion and deletions
    delIndex <- which(grepl("D", cigar(indelReads)))
    insIndex <- which(grepl("I", cigar(indelReads)))
    indelIndex <- sort(c(delIndex, insIndex))
    
    # Every other read will support the reference
    everything <- seq(1, length(indelReads), 1)
    refIndex <- which(is.na(match(everything, indelIndex)))
    refSupport <- indelReads[refIndex]
    
    # Now this contains just indel reads
    # Hopefully this will speed things up with less iteration
    indelReads <- indelReads[indelIndex]
    
    message("Tallying indels for: ", bam)

    if (length(indelIndex) > 500) {
      message("This may take a while, determining ", length(indelIndex), " indel reads for ", bam)
    }
    
    # Returns the ref and alt read for each variant
    #lapply(indelReads, .reverseCigar, ref=ref)
    for (i in 1:length(indelReads)) {
      indelReads[i] <- .reverseCigar(indelReads[i], ref, refSeqDNA)
    }

    # Converts to a MVRanges
    mvrIndel <- .indelToMVR(indelReads,refSupport, ref, bam) 

    # Copied and pasted from below
    mvrIndel$VAF <- altDepth(mvrIndel)/totalDepth(mvrIndel)
    metadata(mvrIndel)$refseq <- refSeqDNA
    
    ### Not sure how to apply this to the indels
    #covg <- rep(0, length(metadata(mvrIndel)$refseq))
    #covered <- rowsum(altDepth(mvrIndel), pos(mvrIndel))
    #covg[as.numeric(rownames(covered))] <- covered 
    #metadata(mvrIndel)$coverageRle <- Rle(covg)
    
    metadata(mvrIndel)$bam <- basename(bam)
    metadata(mvrIndel)$sbp <- indelSBP
    metadata(mvrIndel)$pup <- pup
    mvrIndel$bam <- basename(bam)
    genome(mvrIndel) <- ref
    
    # cigar(indelReads)
    # 
    
    
    #message("Warning: indels are not currently supported in pileupMT()")
    #message("(However, if you debug() this function, indelReads will help.")
  }
  # data(fpFilter_Triska, package="MTseeker") # for when they are... 
  
  message("Tallying SNPs for: ", bam)

  # this may belong in a separate helper function...
  pu <- subset(pu, nucleotide %in% c('A','C','G','T'))
  pu$which_label <- NULL # confusing here 
  pu$ref <-  factor(strsplit(as.character(refSeqDNA), '')[[1]],
                    levels=levels(pu$nucleotide))[pu$pos]
  
  pu$alt <- pu$nucleotide 
  pu$totalDepth <- .byPos(pu, "count")
  is.na(pu$alt) <- (pu$nucleotide == pu$ref)
  pu$altDepth <- ifelse(is.na(pu$alt), NA_integer_, pu$count) 
  pu$refDepth <- pu$totalDepth - .byPos(pu, "altDepth")
  pu$isAlt <- !is.na(pu$alt)
  pu$alleles <- .byPos(pu, "isAlt") + 1 
  columns <- c("seqnames","pos","ref","alt","totalDepth","refDepth","altDepth")
  gr <- keepSeqlevels(.puToGR(subset(pu, isAlt|alleles==1)[,columns]),
                      unique(pu$seqnames))
  
  # seqnames for mouse genome is "MT" 
  seqinfo(gr) <- Seqinfo(levels(seqnames(gr)), width(refSeqDNA), 
                         isCircular=TRUE, genome=ref)
  vr <- makeVRangesFromGRanges(.puToGR(subset(pu, isAlt|alleles==1)[,columns]))
  vr <- keepSeqlevels(vr, levels(seqnames(gr))) 
  seqinfo(vr) <- seqinfo(gr)
  mvr <- MVRanges(vr, coverage=median(rowsum(pu$count, pu$pos)))
  sampleNames(mvr) <- base::sub(paste0(".", ref), "", 
                                base::sub(".bam", "", 
                                          basename(bam)))
  names(mvr)[which(mvr$ref != mvr$alt)] <- MTHGVS(subset(mvr, ref != alt)) 
  altDepth(mvr)[is.na(altDepth(mvr))] <- 0
  
  mvr$VAF <- altDepth(mvr)/totalDepth(mvr)
  metadata(mvr)$refseq <- refSeqDNA
  covg <- rep(0, length(metadata(mvr)$refseq))
  covered <- rowsum(pu$count, pu$pos)
  covg[as.numeric(rownames(covered))] <- covered 
  metadata(mvr)$coverageRle <- Rle(covg)
  metadata(mvr)$bam <- basename(bam)
  metadata(mvr)$sbp <- sbp
  metadata(mvr)$pup <- pup
  mvr$bam <- basename(bam)
  genome(mvr) <- ref
  
  # Only want to keep variants that differ from reference
  keep <- which(!is.na(alt(mvr)))
  mvr <- mvr[keep]
  names(mvr) <- MTHGVS(mvr)

  # Add in the indels if they exist
  if (nrow(indels) > 0) {
    
    mvr <- MVRanges(c(mvr, mvrIndel))
    mvr <- sort(mvr)
    
    # Not sure how else to establish coverage for the mvr
    #mvr <- MVRanges(mvr, coverage=median(altDepth(mvr), start(mvr), na.rm=T))
  }

  return(mvr)
}


# helper fn
.byPos <- function(x, y) { 
  rowsum(as.numeric(x[,y]), as.character(x$pos), na.rm=1)[as.character(x$pos),]
}


# helper fn
.puToGR <- function(pu) { 
  makeGRangesFromDataFrame(pu, start.field="pos", end.field="pos", strand="*",
                           keep.extra.columns=TRUE)
}


# helper fn
.refSeqLengths <- function() { 
  
  refSeqLengths <- c() 
  data(rCRSeq, package="MTseeker") # human
  data(NC_005089seq, package="MTseeker") # mouse 
  # data(mtRefs, package="MTseeker") # both
  refSeqLengths["rCRS"] <- width(rCRSeq)
  refSeqLengths["GRCh38"] <- width(rCRSeq)
  refSeqLengths["hg38"] <- width(rCRSeq)
  refSeqLengths["GRCh37"] <- width(rCRSeq)
  refSeqLengths["NC_005089"] <- width(NC_005089seq)
  refSeqLengths["GRCm38"] <- width(NC_005089seq)
  refSeqLengths["mm10"] <- width(NC_005089seq) 
  refSeqLengths["C57BL/6J"] <- width(NC_005089seq)
  return(refSeqLengths)
  
}


# helper fn
.getRefSyn <- function(ref) {
  
  # simplify references down to the supported "mouse" or "human" mitogenomes 
  if (ref %in% c("C57BL/6J", "NC_005089", "GRCm38","mm10")) ref <- "NC_005089"
  if (ref %in% c("hg38", "GRCh37", "GRCh38")) ref <- "rCRS" 
  return(ref)
  
}


# helper fn
.getRefSeq <- function(ref) { 
  
  data(rCRSeq, package="MTseeker") # human
  data(NC_005089seq, package="MTseeker") # mouse
  refs <- DNAStringSet(c(rCRS=rCRSeq[['chrM']],
                         NC_005089=NC_005089seq[['chrM']]))
  return(refs[.getRefSyn(ref)])
  
}

# helper fn
# Will take a single read and return the reference and alternative sequence
.reverseCigar <- function(indelRead, ref, reference) {
  
  # These are reads that support the reference
  if ( (!grepl("I", cigar(indelRead))) && (!grepl("D", cigar(indelRead))) ) {
    return(indelRead)
    #print("All matched")
  }
  
  else {
    
    # Keep track of how many base pairs are being added in the cigar string
    # Add matches
    addPos <- 0
    # Add soft clippings
    softPos <- 0
    
    #reference <- .getRefSeq(ref)
    
    splitCigar <- gsub("([[:digit:]]+[[:alpha:]])", "\\1 ", cigar(indelRead))
    splitCigar <- unlist(strsplit(splitCigar, " "))
    
    # Find the insertion or deletion
    insIndex <- which((grepl("I", splitCigar))) 
    delIndex <- which((grepl("D", splitCigar))) 
    
    # Currently do not support reads that have multiple indels in it
    if (length(insIndex) >= 1 && length(delIndex) >= 1) {
      warning("Insertion and deletion in ", cigar(indelRead), " skipping it...")
      return(indelRead)
    }
    
    if (length(insIndex) > 1 || length(delIndex) > 1) {
      warning("More than one insertion or deletion in ", cigar(indelRead), " skipping it...")
      return(indelRead)
    }
    
    # There is an insertion
    if (length(insIndex)) {
      
      # Find the number of base pairs that are soft clips
      # Only want to look at the information before the insertion
      softPos <- which(grepl("S", splitCigar[1:insIndex]))
      softPos <- as.numeric(gsub("\\D", "", splitCigar[softPos]))
      if (length(softPos) == 0) {
        softPos <- 0
      }
      
      # Find the number of base pairs that are matches
      # Only want to look at the information before the insertion
      addPos <- which(grepl("M", splitCigar[1:insIndex]))
      addPos <- as.numeric(gsub("\\D", "", splitCigar[addPos]))
      if (length(addPos) == 0) {
        addPos <- 0
      }
      
      ## This is where the actual insertion stuff occurs
      # Create range for the deletion
      startPos <- start(indelRead) + addPos
      
      # Deal with the off by one error for the start of the range
      if (softPos == 0) {  
        startPos <- startPos - 1
      }
      
      # According to VRanges documentation, insertions have width=1 soooo
      endPos <- startPos
      
      # Length of insertion
      insLength <- as.numeric(gsub("\\D", "", splitCigar[insIndex]))
      
      # Get the reference
      refs <- extractAt(reference, IRanges(startPos, endPos))
      refs <- unname(as.character(unlist(refs)))
      
      # Get the alt sequence from the raw read
      altSeq <- as.character(mcols(indelRead)$seq)
      altSplit <- unlist(strsplit(altSeq, split=""))
      
      altIndex <- seq(addPos, addPos + insLength, 1)
      alt <- altSplit[altIndex]
      alt <- paste(alt, collapse="")
      
      ################################
      # SANITY CHECKS
      
      #testRef <- extractAt(reference, IRanges(startPos, startPos))
      #testRef <- as.character(unlist(testRef))
      
      # Get the corresponding ref sequence
      #refRange <- IRanges(start(indelRead) - softPos, end(indelRead))
      #refSeq <- as.character(unlist(extractAt(reference, refRange)))
      
      # Compare the two strings
      # Tried doing this using positions based upon cigar string but sometimes got off by one errors
      #comp <- pairwiseAlignment(refSeq, altSeq)
      #show(comp)
      
      # Make the ref and alt sequences into vectors of characters to look at each character individually
      #refSplit <- unlist(strsplit(as.character(pattern(comp)), split=""))
      
      ###################################
      
      # Store the information
      mcols(indelRead)$indelStart <- startPos
      mcols(indelRead)$indelEnd <- endPos
      mcols(indelRead)$alt <- alt
      mcols(indelRead)$ref <- refs
      
    }
    
    else if (length(delIndex)) {
      
      # Find the number of base pairs that are soft clips
      # Only want to look at the information before the delection
      softPos <- which(grepl("S", splitCigar[1:delIndex]))
      softPos <- as.numeric(gsub("\\D", "", splitCigar[softPos]))
      if (length(softPos) == 0) {
        softPos <- 0
      }
      
      # Find the number of base pairs that are matches
      # Only want to look at the information before the deletion
      addPos <- which(grepl("M", splitCigar[1:delIndex]))
      addPos <- as.numeric(gsub("\\D", "", splitCigar[addPos]))
      if (length(addPos) == 0) {
        addPos <- 0
      }
      
      ## This is where the actual deletion takes place
      # Create range for the deletion
      startPos <- start(indelRead) + addPos
      
      # These appear to cause one off errors for the start of the range
      testRef <- extractAt(reference, IRanges(startPos, startPos))
      testRef <- as.character(unlist(testRef))
      if (testRef == "N" || softPos == 0) {  ## THROW OUT ALL Ns and if deletion is length 1 #rCRS:m.3107del
        startPos <- startPos - 1
      }
      
      endPos <- startPos + as.numeric(gsub("\\D", "", splitCigar[delIndex]))
      
      # Get the reference
      refs <- extractAt(reference, IRanges(startPos, endPos))
      refs <- unname(as.character(unlist(refs)))
      
      # Do the deletion
      # Since we are subtracting 1, we are deleting all of the sequences that come after the start
      # So we just want to keep the first sequence
      alt <- extractAt(reference, IRanges(startPos, startPos))
      alt <- unname(unstrsplit(CharacterList(alt)))
      
      ##########################################
      # Just a manual check for my own sanity to make sure that this works
      
      # Get the alt sequence 
      #altSeq <- as.character(mcols(indelRead)$seq)
      
      # Get the corresponding ref sequence
      #refRange <- IRanges(start(indelRead) - softPos, end(indelRead))
      #refSeq <- as.character(unlist(extractAt(reference, refRange)))
      
      # Compare the two strings
      # Tried doing this using positions based upon cigar string but sometimes got off by one errors
      #comp <- pairwiseAlignment(refSeq, altSeq)
      
      #show(comp)
      #show(refs)
      #show(alt)
      ############################################
      
      # Store the information
      mcols(indelRead)$indelStart <- startPos
      mcols(indelRead)$indelEnd <- endPos
      mcols(indelRead)$alt <- alt
      mcols(indelRead)$ref <- refs
       
    } # D
    
  } # Else 
  
  return(indelRead)
}

# helper fn
# Will make turn the indel information into a MVRanges
.indelToMVR <- function(indelReads, refSupport, ref, bam) {
  
  # This is mostly copied and pasted from the mvr created at the end of pileup
  indelSupport <- which(!is.na(mcols(indelReads)$alt))
  indelSupport <- indelReads[indelSupport]
  indelSupport <- as.data.frame(indelSupport)
  
  indelSupport$which_label <- NULL
  
  indelSupport$refDepth <- NA_integer_
  indelSupport$altDepth <- 1
  indelSupport$totalDepth <- 1
  
  indelSupport$isAlt <- TRUE
  
  ### Not sure what this line is supposed to do
  #pu$alleles <- .byPos(pu, "isAlt") + 1 
  
  #### DO I WANT TO DO THIS??
  indelSupport$pos <- as.numeric(indelSupport$indelStart)
  
  # Turn into granges then turn into vranges
  columns <- c("seqnames","pos","ref","alt","totalDepth","refDepth","altDepth")
  grIndel <- keepSeqlevels(.puToGR(subset(indelSupport, isAlt==1)[,columns]), unique(indelSupport$seqnames))
  seqinfo(grIndel) <- Seqinfo(levels(seqnames(grIndel)), width(.getRefSeq(ref)), isCircular=TRUE, genome=ref)
  
  vrIndel <- makeVRangesFromGRanges(.puToGR(subset(indelSupport, isAlt==1)[,columns]))
  vrIndel <- keepSeqlevels(vrIndel, levels(seqnames(grIndel))) 
  seqinfo(vrIndel) <- seqinfo(grIndel)
  
  # Skipped this coverage step
  ### IS THAT ALRIGHT?
  #mvr <- MVRanges(vr, coverage=median(rowsum(pu$count, pu$pos)))
  
  # Turn into mvranges
  mvrIndel <- MVRanges(vrIndel)
  sampleNames(mvrIndel) <- base::sub(paste0(".", ref), "", base::sub(".bam", "",  basename(bam)))
  
  # Fix ranges
  indelRanges <- IRanges(as.numeric(indelSupport$indelStart), as.numeric(indelSupport$indelEnd))
  ranges(mvrIndel) <- indelRanges
  
  # Assign names
  names(mvrIndel)[which(ref(mvrIndel) != alt(mvrIndel))] <- MTHGVS(subset(mvrIndel, ref != alt)) 
  
  # Only keep unique variants (based upon names that were just assigned)
  mvrIndelunique <- unique(mvrIndel)
  
  # Assign altDepths based upon what was unique
  # Sometimes the order gets mixed up, so gotta keep track of that
  order <- match(names(mvrIndelunique), names(table(names(mvrIndel))))
  count <- unname(table(names(mvrIndel))[order])
  altDepth(mvrIndelunique) <- count
  
  # Now have to get the refDepth from indelReads that were all matched
  # Added this as an argument to speed up processes
  
  #refDepth(mvrIndelunique) <- 0
  #refSupport <- which(is.na(mcols(indelReads)$alt))
  #refSupport <- indelReads[refSupport]
  
  # Need to keep order in mind, since not every indel has a read supporting the reference
  # Sets the refDepth to corresponding index that is matched
  ov <- findOverlaps(refSupport, mvrIndelunique)
  refCount <- table(subjectHits(ov))
  refDepth(mvrIndelunique[as.numeric(names(refCount))]) <- as.numeric(unname(refCount))
  
  # Replace NA's with 0s for refDepth to properly calculate totalDepth
  noRef <- which(is.na(refDepth(mvrIndelunique)))
  refDepth(mvrIndelunique[noRef]) <- 0
  
  # Recalculate totalDepth
  totalDepth(mvrIndelunique) <- refDepth(mvrIndelunique) + altDepth(mvrIndelunique)
  
  # Want to make sure we keep track of coverage
  ### NOT SURE HOW TO KEEP TRACK OF THE COVERAGE
  #mvr <- MVRanges(mvrIndelunique, coverage = median(rowsum(altDepth(mvrIndel), start(mvrIndel))))
  mvr <- MVRanges(mvrIndelunique)
  return(mvr)
  
}
